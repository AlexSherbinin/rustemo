use crate::{
    error::Result,
    location::{LineBased, Location, Position},
};
use core::fmt::Debug;
use std::{cmp::min, iter::once, ops::Range, path::Path};

/// The `Lexer` trait allows input tokenization
///
/// Lexer is stateless and its job is to produce next token given the current
/// context.
///
/// # Generic types
///
/// - `I` - the type of the input.
/// - `ST` - parser state type. E.g. for LR parsing this is [StateIndex]
/// - `TK` - token kind type. This is generated by the parser generator from the
///   grammar. This is the type that describes the kinds of token lexer can
///   produce.
///
pub trait Lexer<'i, I: Input + ?Sized, ST, TK> {
    /// Given the current context, this method should return a result with token
    /// found ahead of the current location or error indicating what is
    /// expected. Context should be updated to reflect the progress in the
    /// input, i.e. its
    fn next_token(
        &self,
        context: &mut Context<'i, I, ST>,
    ) -> Result<Token<'i, I, TK>>;
}

/// This trait must be implemented by all types that should be parsed by
/// Rustemo. Input is a sliceable sequence-like type with a concept of length.
pub trait Input: ToOwned {
    /// Returns a string context for the given position. Used in debugging outputs.
    fn context_str(&self, position: usize) -> String;

    /// Returns the length of the input.
    fn len(&self) -> usize;

    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    fn slice(&self, range: &Range<usize>) -> &Self;

    fn read_file<P: AsRef<Path>>(path: P) -> Result<Self::Owned>;

    fn start_location() -> Location {
        Location {
            start: Position::Position(0),
            end: None,
        }
    }

    /// Given the current location returns the location at the end of self.
    /// Location is an input-specific concept. E.g. for text it is line/column.
    fn location_after(&self, location: Location) -> Location;

    /// Given the current location returns a span starting from the current
    /// location and extending over self. The `self.start` should not be changed,
    /// only `self.end` where `self.end` should be `self.start`
    fn location_span(&self, location: Location) -> Location {
        Location {
            start: location.start,
            end: Some(self.location_after(location).start),
        }
    }
}

pub trait AsStr {
    fn as_str(&self) -> &'static str;
}

/// `Token` represent a single token from the input stream.
#[derive(Debug)]
pub struct Token<'i, I: Input + ?Sized, TK> {
    pub kind: TK,

    /// The part of the input stream that this token represents.
    pub value: &'i I,

    /// Location (with span) in the input file where this token is found.
    pub location: Location,
}

/// Lexer context is used to keep the lexing state. It provides necessary
/// information to parsers and actions.
#[derive(Debug)]
pub struct Context<'i, I: Input + ?Sized, ST> {
    /// File path of the parsed content. `<str>` In case of static string.
    pub file: String,

    /// The input being parsed. Should be set when the context is created.
    pub input: &'i I,

    /// An absolute position in the input sequence
    ///
    /// The input must be indexable type.
    pub position: usize,

    /// The range of token/non-terminal during shift/reduce operation.
    pub range: Range<usize>,

    /// Location in the input if the input is line/column based.
    ///
    /// The location should be tracked by lexer but the lexers are stateless so
    /// the current location is always kept in the context. As location tracking
    /// incurs an overhead it should be configurable. In case of an error, lexer
    /// can calculate location information based on the absolute position.
    pub location: Location,

    /// Layout before the current token (e.g. whitespaces, comments...)
    pub layout: Option<&'i I>,

    /// Layout before the lookahead token (e.g. whitespaces, comments...)
    pub layout_ahead: Option<&'i I>,

    /// An arbitrary state used by the parser. E.g. for LR it is the current
    /// state of the automaton.
    pub state: ST,
}

impl<'i, I: Input + ?Sized, ST: Default> Context<'i, I, ST> {
    pub fn new(file: String, input: &'i I) -> Self {
        Self {
            file,
            input,
            position: 0,
            location: I::start_location(),
            layout: None,
            layout_ahead: None,
            state: ST::default(),
            range: 0..0,
        }
    }

    #[inline]
    pub fn file(&self) -> String {
        self.file.clone()
    }

    #[inline]
    pub fn location_str(&self) -> String {
        format!("{}:{}", self.file(), self.location)
    }
}

impl Input for str {
    fn context_str(&self, position: usize) -> String {
        self[position - min(15, position)..position]
            .chars()
            .chain("-->".chars())
            .chain(self[position..].chars().take(15))
            .collect::<String>()
    }

    fn len(&self) -> usize {
        str::len(self)
    }

    fn slice(&self, range: &Range<usize>) -> &Self {
        &self[range.start..range.end]
    }

    fn start_location() -> Location {
        Location {
            start: Position::LineBased(LineBased { line: 1, column: 0 }),
            end: None,
        }
    }

    fn location_after(&self, location: Location) -> Location {
        let (mut line, mut column) = match location {
            Location {
                start: Position::LineBased(lb),
                ..
            } => (lb.line, lb.column),
            _ => panic!("Location not in line/column format!"),
        };

        line += self.as_bytes().iter().filter(|&c| *c == b'\n').count();
        if let Some(new_col) = self.as_bytes().iter().rposition(|&c| c == b'\n')
        {
            column = self.len() - new_col - 1;
        } else {
            column += self.len();
        }

        Location {
            start: Position::LineBased(LineBased { line, column }),
            end: None,
        }
    }

    fn read_file<P: AsRef<Path>>(path: P) -> Result<Self::Owned> {
        Ok(std::fs::read_to_string(path)?)
    }
}

impl Input for [u8] {
    fn context_str(&self, position: usize) -> String {
        format!(
            "{:?}",
            self[position - min(15, position)..position]
                .iter()
                .map(|x| format!("{x}"))
                .chain(once("-->".to_string()))
                .chain(self[position..].iter().map(|x| format!("{x}")).take(15))
                .collect::<Vec<_>>()
        )
    }

    fn len(&self) -> usize {
        self.len()
    }

    fn slice(&self, range: &Range<usize>) -> &Self {
        &self[range.start..range.end]
    }

    fn location_after(&self, location: Location) -> Location {
        if let Location {
            start: Position::Position(p),
            ..
        } = location
        {
            Location {
                start: Position::Position(p + self.len()),
                end: None,
            }
        } else {
            Location {
                start: Position::Position(self.len()),
                end: None,
            }
        }
    }

    fn read_file<P: AsRef<Path>>(path: P) -> Result<Self::Owned> {
        Ok(std::fs::read(path)?)
    }
}

impl<'i, I: Input + ?Sized, ST: Default> From<&mut Context<'i, I, ST>>
    for Location
{
    fn from(context: &mut Context<I, ST>) -> Self {
        context.location
    }
}
