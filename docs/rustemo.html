<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-30 Wed 17:44 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rustemo book</title>
<meta name="author" content="Igor Dejanovic" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="worg.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Rustemo book</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orge18d074">1. Introduction</a>
<ul>
<li><a href="#org1d2d5ba">1.1. Introduction</a></li>
<li><a href="#orga1f625b">1.2. Overview</a></li>
<li><a href="#orgd32c078">1.3. Quick start</a></li>
<li><a href="#org869efd6">1.4. Parsing process</a></li>
</ul>
</li>
<li><a href="#the-rustemo-grammar-language">2. Grammar language</a>
<ul>
<li><a href="#the-structure-of-the-grammar">2.1. The structure of the grammar</a></li>
<li><a href="#terminals">2.2. Terminals</a></li>
<li><a href="#usual-patterns">2.3. Usual patterns</a></li>
<li><a href="#syntactic-sugar-bnf-extensions">2.4. Syntactic sugar - BNF extensions</a></li>
<li><a href="#empty-built-in-rule">2.5. <code>EMPTY</code> built-in rule</a></li>
<li><a href="#named-matches-assignments">2.6. Named matches (<i>assignments</i>)</a></li>
<li><a href="#referencing-semantic-actions-from-a-grammar">2.7. Referencing semantic actions from a grammar</a></li>
<li><a href="#user-meta-data">2.8. User meta-data</a></li>
<li><a href="#grammar-comments">2.9. Grammar comments</a></li>
<li><a href="#handling-whitespaces-and-comments-in-your-language">2.10. Handling whitespaces and comments in your language</a></li>
<li><a href="#handling-keywords-in-your-language">2.11. Handling keywords in your language</a></li>
</ul>
</li>
<li><a href="#org4dc300c">3. Configuration</a>
<ul>
<li><a href="#org09a2941">3.1. Configuration</a></li>
<li><a href="#org5dc3301">3.2. <code>build.rs</code> scripts</a></li>
<li><a href="#org6e14d7b">3.3. Using API</a></li>
</ul>
</li>
<li><a href="#org79cae78">4. Components</a>
<ul>
<li><a href="#org7aabd9b">4.1. Components</a></li>
<li><a href="#orgcc9dc2b">4.2. Lexers</a></li>
<li><a href="#orgf692533">4.3. Parsers</a></li>
<li><a href="#orgb112195">4.4. Builders</a></li>
</ul>
</li>
<li><a href="#orgf2dcbef">5. Rustemo CLI</a></li>
<li><a href="#org7393b97">6. Handling errors</a>
<ul>
<li><a href="#org295b854">6.1. Handling errors</a></li>
<li><a href="#resolving-lr-conflicts">6.2. Resolving LR conflicts</a></li>
<li><a href="#org7848243">6.3. Ambiguities</a></li>
</ul>
</li>
<li><a href="#org6afc27b">7. Tutorials</a>
<ul>
<li><a href="#org0683174">7.1. Calculator</a></li>
</ul>
</li>
<li><a href="#org0605872">8. Contributing</a>
<ul>
<li><a href="#org92108f6">8.1. Contributing</a></li>
<li><a href="#org9f3a288">8.2. Bootstrapping</a></li>
</ul>
</li>
<li><a href="#org8621dd2">9. Random notes</a>
<ul>
<li><a href="#org6306f46">9.1. Random notes</a></li>
<li><a href="#orgcefb2b2">9.2. <code>@vec</code> rule annotation</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge18d074" class="outline-2">
<h2 id="orge18d074"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org1d2d5ba" class="outline-3">
<h3 id="org1d2d5ba"><span class="section-number-3">1.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-1-1">
</div>
</div>

<div id="outline-container-orga1f625b" class="outline-3">
<h3 id="orga1f625b"><span class="section-number-3">1.2.</span> Overview</h3>
</div>
<div id="outline-container-orgd32c078" class="outline-3">
<h3 id="orgd32c078"><span class="section-number-3">1.3.</span> Quick start</h3>
<div class="outline-text-3" id="text-1-3">
</div>
</div>
<div id="outline-container-org869efd6" class="outline-3">
<h3 id="org869efd6"><span class="section-number-3">1.4.</span> Parsing process</h3>
<div class="outline-text-3" id="text-1-4">
<p>
This section describes the overall parsing process and interplay of parser,
lexer and builder.
</p>


<div id="org53f5548" class="figure">
<p><img src="img/parsing-process.png" alt="parsing-process.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-the-rustemo-grammar-language" class="outline-2">
<h2 id="the-rustemo-grammar-language"><span class="section-number-2">2.</span> Grammar language</h2>
<div class="outline-text-2" id="text-the-rustemo-grammar-language">
<p>
This section describe the grammar language, its syntax and semantics rules.
</p>

<div class="warning" id="org94f4861">
<p>
This document is ported from <a href="https://github.com/igordejanovic/parglare">the parglare project</a>. Rustemo and this doc are
still work in progress and not all features of parglare are implemented yet.
</p>

</div>


<div id="org1cda882" class="figure">
<p><img src="test-plant.png" alt="test-plant.png" />
</p>
</div>



<div id="orgc809be2" class="figure">
<p><img src="test-mermaid.png" alt="test-mermaid.png" />
</p>
</div>

<p>
The Rustemo grammar specification language is based on <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a> with <a href="#syntactic-sugar-bnf-extensions">syntactic sugar
extensions</a> which are optional and builds on top of a pure BNF. Rustemo is
based on <a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context-Free Grammars (CFGs)</a> and a grammar is written declaratively.
You don&rsquo;t have to think about the parsing process like in e.g. <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEGs</a>. Ambiguities
are dealt with explicitly (see the <a href="#resolving-lr-conflicts">section on conflicts</a>).
</p>
</div>

<div id="outline-container-the-structure-of-the-grammar" class="outline-3">
<h3 id="the-structure-of-the-grammar"><span class="section-number-3">2.1.</span> The structure of the grammar</h3>
<div class="outline-text-3" id="text-the-structure-of-the-grammar">
<p>
Each grammar file consists of two parts: - derivation/production rules -
optional terminal definitions which are written after the keyword
<code>terminals</code>.
</p>

<p>
Each derivation/production rule is of the form:
</p>

<pre class="example" id="org322ef03">
&lt;symbol&gt;: &lt;expression&gt; ;
</pre>

<p>
where <code>&lt;symbol&gt;</code> is grammar non-terminal and <code>&lt;expression&gt;</code> is one or
more sequences of grammar symbol references separated by choice operator
<code>|</code>.
</p>

<p>
For example:
</p>

<pre class="example" id="orgb9067e0">
Fields: Field | Fields "," Field;
</pre>

<p>
Here <code>Fields</code> is a non-terminal grammar symbol and it is defined as
either a single <code>Field</code> or, recursively, as <code>Fields</code> followed by a
string terminal <code>,</code> and than by another <code>Field</code>. It is not given here
but <code>Field</code> could also be defined as a non-terminal. For example:
</p>

<pre class="example" id="orgffd3db7">
Field: QuotedField | FieldContent;
</pre>

<p>
Or it could be defined as a terminal in terminals section:
</p>

<pre class="example" id="org00fdc97">
terminals
Field: /[A-Z]*/;
</pre>

<p>
This terminal definition uses regular expression recognizer.
</p>
</div>
</div>
<div id="outline-container-terminals" class="outline-3">
<h3 id="terminals"><span class="section-number-3">2.2.</span> Terminals</h3>
<div class="outline-text-3" id="text-terminals">
<p>
Terminal symbols of the grammar define the fundamental or atomic
elements of your language &#x2013; tokens or lexemes (e.g.Â keywords, numbers).
</p>

<p>
Terminals are given at the end of the grammar file, after production
rules, following the keyword <code>terminals</code>.
</p>

<p>
Tokens are recognized from the input by a component called <code>lexer</code>.
Rustemo provides a string lexer out-of-the-box. If more control is
needed, or if non-textual context has been parsed a custom lexer must be
provided. See the <a href="./lexers.md">lexers section</a> for more.
</p>

<p>
The grammar language enables specification of two kinds of terminal
matches: - string match - regex match
</p>
</div>

<div id="outline-container-string-recognizer" class="outline-4">
<h4 id="string-recognizer"><span class="section-number-4">2.2.1.</span> String recognizer</h4>
<div class="outline-text-4" id="text-string-recognizer">
<p>
String recognizer is defined as a plain string inside of double quotes:
</p>

<pre class="example" id="orgb720401">
my_rule: "start" other_rule "end";
</pre>

<p>
In this example <code>"start"</code> and <code>"end"</code> will be terminals with string
recognizers that match exactly the words <code>start</code> and <code>end</code>.
</p>

<p>
You can write string recognizing terminal directly in the rule
expression or you can define terminal separately and reference it by
name, like:
</p>

<pre class="example" id="org72061d0">
my_rule: start other_rule end;

terminals
start: "start";
end: "end";
</pre>

<p>
Either way it will be the same terminal. You can&rsquo;t mix those two
approaches for a single terminal. If you defined a terminal in the
<code>terminals</code> section than you can&rsquo;t use inline string matches for that
terminal.
</p>

<p>
You will usually write it as a separate terminal if the terminal is used
at multiple places in the grammar or to provide disambiguation
information for a terminal (priority, <code>prefer</code> etc.).
</p>
</div>
</div>

<div id="outline-container-regular-expression-recognizer" class="outline-4">
<h4 id="regular-expression-recognizer"><span class="section-number-4">2.2.2.</span> Regular expression recognizer</h4>
<div class="outline-text-4" id="text-regular-expression-recognizer">
<p>
Or regex recognizer for short is a regex pattern written inside slashes
(<code>/.../</code>).
</p>

<p>
For example:
</p>

<pre class="example" id="org517e525">
number: /\d+/;
</pre>

<p>
This rule defines terminal symbol <code>number</code> which has a regex recognizer
and will recognize one or more digits as a number.
</p>

<pre class="example" id="orge64e28c">
You cannot write regex recognizers inline like you can do with string
recognizers. This constraint is introduced because there is no sane way to
deduce terminal name given its regex. Thus, you must write all regex
recognizers/terminals in the `terminals` section at the end of the grammar
file.
</pre>
</div>
</div>

<div id="outline-container-custom-recognizers" class="outline-4">
<h4 id="custom-recognizers"><span class="section-number-4">2.2.3.</span> Custom recognizers</h4>
<div class="outline-text-4" id="text-custom-recognizers">
<p>
If you are parsing arbitrary input (non-textual) you&rsquo;ll have to provide
your own recognizers. In the grammar, you just have to provide terminal
symbol without body, i.e.Â without string or regex recognizer. You will
provide missing recognizers during grammar instantiation from Python.
Although you don&rsquo;t supply body of the terminal you can define
<a href="./disambiguation.md">disambiguation rules</a> as usual.
</p>

<p>
Lets say that we have a list of integers (real list of Python ints, not
a text with numbers) and we have some weird requirement to break those
numbers according to the following grammar:
</p>

<pre class="example" id="orgf8b5550">
Numbers: all_less_than_five  ascending  all_less_than_five;
all_less_than_five: all_less_than_five  int_less_than_five
                  | int_less_than_five;


terminals
// These terminals have no recognizers defined in the grammar
ascending: ;
int_less_than_five: ;
</pre>

<p>
So, we should first match all numbers less than five and collect those,
than we should match a list of ascending numbers and than list of less
than five again. <code>int_less_than_five</code> and <code>ascending</code> are
terminals/recognizers that will be defined in Python and passed to
grammar construction. <code>int_less_than_five</code> will recognize Python integer
that is, well, less than five. <code>ascending</code> will recognize a sublist of
integers in ascending order.
</p>

<p>
More on this topic can be found in <a href="./recognizers.md">a separate
section</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-usual-patterns" class="outline-3">
<h3 id="usual-patterns"><span class="section-number-3">2.3.</span> Usual patterns</h3>
<div class="outline-text-3" id="text-usual-patterns">
<p>
This section explains how some common grammar patterns can be written
using just a plain BNF notation.
</p>
</div>

<div id="outline-container-one-or-more" class="outline-4">
<h4 id="one-or-more"><span class="section-number-4">2.3.1.</span> One or more</h4>
<div class="outline-text-4" id="text-one-or-more">
<pre class="example" id="org6a6aebb">
// sections rule below will match one or more section.
sections: sections section | section;
</pre>

<p>
In this example <code>sections</code> will match one or more <code>section</code>. Notice the
recursive definition of the rule. You can read this as <i><code>sections</code> is
either a single section or <code>sections</code> and a <code>section</code></i>.
</p>

<pre class="example" id="org6234544">
Please note that you could do the same with this rule:

    sections: section sections | section;

which will give you similar result but the resulting tree will be different.
Notice the recursive reference is now at the and of the first production.
Previous example will reduce sections early and than add another section to it,
thus the tree will be expanding to the left. The example in this note will
collect all the sections and than start reducing from the end, thus building a
tree expanding to the right. These are subtle differences that are important
when you start writing your semantic actions. Most of the time you don't care
about this so use the first version as it is more efficient and Rustemo
provides built-in actions for these common cases.
</pre>
</div>
</div>

<div id="outline-container-zero-or-more" class="outline-4">
<h4 id="zero-or-more"><span class="section-number-4">2.3.2.</span> Zero or more</h4>
<div class="outline-text-4" id="text-zero-or-more">
<pre class="example" id="orgeb5e946">
// sections rule below will match zero or more section.
sections: sections section | section | EMPTY;
</pre>

<p>
In this example <code>sections</code> will match zero or more <code>section</code>. Notice the
addition of the <code>EMPTY</code> choice at the end. This means that matching
nothing is a valid <code>sections</code> non-terminal.
</p>

<p>
Same note from above applies here to.
</p>
</div>
</div>

<div id="outline-container-optional" class="outline-4">
<h4 id="optional"><span class="section-number-4">2.3.3.</span> Optional</h4>
<div class="outline-text-4" id="text-optional">
<pre class="example" id="org3169715">
document: optheader body;
optheader: header | EMPTY;
</pre>

<p>
In this example <code>optheader</code> is either a header or nothing.
</p>
</div>
</div>
</div>

<div id="outline-container-syntactic-sugar-bnf-extensions" class="outline-3">
<h3 id="syntactic-sugar-bnf-extensions"><span class="section-number-3">2.4.</span> Syntactic sugar - BNF extensions</h3>
<div class="outline-text-3" id="text-syntactic-sugar-bnf-extensions">
<p>
Previous section gives the overview of the basic BNF syntax. If you got
to use various BNF extensions (like
<a href="https://en.wikipedia.org/wiki/Kleene_star">Kleene star</a>) you might
find writing patterns in the previous section awkward. Since some of the
patterns are used frequently in the grammars (zero-or-more, one-or-more
etc.) Rustemo provides syntactic sugar for this common idioms using a
well known regular expression syntax.
</p>
</div>

<div id="outline-container-optional-1" class="outline-4">
<h4 id="optional-1"><span class="section-number-4">2.4.1.</span> Optional</h4>
<div class="outline-text-4" id="text-optional-1">
<p>
<code>Optional</code> can be specified using <code>?</code>. For example:
</p>

<pre class="example" id="orgbd7e325">
S: "2" b? "3"?;

terminals
b: "1";
</pre>

<p>
Here, after <code>2</code> we might have terminal <code>b</code> but it is optional, as well
as <code>3</code> that follows.
</p>

<p>
Lets see what the parser will return for various inputs (the <code>grammar</code>
variable is a string holding grammar from above):
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dac6d6;">g</span> = Grammar.from_string(grammar)
<span style="color: #dac6d6;">p</span> = Parser(g)

<span style="color: #dac6d6;">input_str</span> = <span style="color: #A2BF8A;">'2 1 3'</span>
<span style="color: #dac6d6;">result</span> = p.parse(input_str)
<span style="color: #80A0C2;">assert</span> result == [<span style="color: #A2BF8A;">"2"</span>, <span style="color: #A2BF8A;">"1"</span>, <span style="color: #A2BF8A;">"3"</span>]

input_str = <span style="color: #A2BF8A;">'2 3'</span>
result = p.parse(input_str)
<span style="color: #80A0C2;">assert</span> result == [<span style="color: #A2BF8A;">"2"</span>, <span style="color: #B58DAE;">None</span>, <span style="color: #A2BF8A;">"3"</span>]
</pre>
</div>

<pre class="example" id="org2b33c42">
Syntax equivalence for `optional` operator:

    S: b?;

    terminals
    b: "1";

is equivalent to:

    S: b_opt;
    b_opt: b | EMPTY;

    terminals
    b: "1";

Behind the scenes Rustemo will create `b_opt` rule.
All syntactic sugar additions operate by creating additional rules in the
grammar during table construction.
</pre>
</div>
</div>

<div id="outline-container-one-or-more-1" class="outline-4">
<h4 id="one-or-more-1"><span class="section-number-4">2.4.2.</span> One or more</h4>
<div class="outline-text-4" id="text-one-or-more-1">
<p>
<code>One or more</code> match is specified using <code>+</code> operator. For example:
</p>

<pre class="example" id="orgb6a8e06">
S: "2" c+;

terminals
c: "c";
</pre>

<p>
After <code>2</code> we expect to see one or more <code>c</code> terminals.
</p>

<p>
Lets see what the parser will return for various inputs (the <code>grammar</code>
variable is a string holding grammar from above):
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dac6d6;">g</span> = Grammar.from_string(grammar)
<span style="color: #dac6d6;">p</span> = Parser(g)

<span style="color: #dac6d6;">input_str</span> = <span style="color: #A2BF8A;">'2 c c c'</span>
<span style="color: #dac6d6;">result</span> = p.parse(input_str)
<span style="color: #80A0C2;">assert</span> result == [<span style="color: #A2BF8A;">"2"</span>, [<span style="color: #A2BF8A;">"c"</span>, <span style="color: #A2BF8A;">"c"</span>, <span style="color: #A2BF8A;">"c"</span>]]

input_str = <span style="color: #A2BF8A;">'2 c'</span>
result = p.parse(input_str)
<span style="color: #80A0C2;">assert</span> result == [<span style="color: #A2BF8A;">"2"</span>, [<span style="color: #A2BF8A;">"c"</span>]]
</pre>
</div>

<p>
So the sub-expression on the second position (<code>c+</code> sub-rule) will by
default produce a list of matched <code>c</code> terminals. If <code>c</code> is missing a
<a href="./handling_errors.md">parse error</a> will be raised.
</p>

<pre class="example" id="orga361499">
Syntax equivalence for `one or more`:

    S: a+;

    terminals
    a: "a";

is equivalent to:

    S: a_1;
    @collect
    a_1: a_1 a | a;

    terminals
    a: "a";
</pre>

<p>
<code>+</code> operator allows repetition modifier for separators. For example:
</p>

<pre class="example" id="org59796ec">
S: "2" c+[comma];

terminals
c: "c";
comma: ",";
</pre>

<p>
<code>c+[comma]</code> will match one or more <code>c</code> terminals separated by whatever
is matched by the <code>comma</code> rule.
</p>

<p>
Lets see what the parser will return for various inputs (the <code>grammar</code>
variable is a string holding grammar from above):
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dac6d6;">g</span> = Grammar.from_string(grammar)
<span style="color: #dac6d6;">p</span> = Parser(g)

<span style="color: #dac6d6;">input_str</span> = <span style="color: #A2BF8A;">'2 c, c,  c'</span>
<span style="color: #dac6d6;">result</span> = p.parse(input_str)
<span style="color: #80A0C2;">assert</span> result == [<span style="color: #A2BF8A;">"2"</span>, [<span style="color: #A2BF8A;">"c"</span>, <span style="color: #A2BF8A;">"c"</span>, <span style="color: #A2BF8A;">"c"</span>]]

input_str = <span style="color: #A2BF8A;">'2 c'</span>
result = p.parse(input_str)
<span style="color: #80A0C2;">assert</span> result == [<span style="color: #A2BF8A;">"2"</span>, [<span style="color: #A2BF8A;">"c"</span>]]
</pre>
</div>

<p>
As you can see giving a separator modifier allows us to parse a list of
items separated by the whatever is matched by the rule given inside
<code>[]</code>.
</p>

<pre class="example" id="org8d2d531">
Syntax equivalence `one or more with separator `:

    S: a+[comma];

    terminals
    a: "a";
    comma: ",";

is equivalent to:

    S: a_1_comma;
    @collect_sep
    a_1_comma: a_1_comma comma a | a;

    terminals
    a: "a";
    comma: ",";

Making the name of the separator rule a suffix of the additional rule
name makes sure that only one additional rule will be added to the
grammar for all instances of `a+[comma]`, i.e. same base rule with the
same separator.
</pre>
</div>
</div>

<div id="outline-container-zero-or-more-1" class="outline-4">
<h4 id="zero-or-more-1"><span class="section-number-4">2.4.3.</span> Zero or more</h4>
<div class="outline-text-4" id="text-zero-or-more-1">
<p>
<code>Zero or more</code> match is specified using <code>*</code> operator. For example:
</p>

<pre class="example" id="org3a00538">
S: "2" c*;

terminals
c: "c";
</pre>

<p>
This syntactic addition is similar to <code>+</code> except that it doesn&rsquo;t require
rule to match at least once. If there is no match, resulting
sub-expression will be an empty list. For example:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dac6d6;">g</span> = Grammar.from_string(grammar)
<span style="color: #dac6d6;">p</span> = Parser(g)

<span style="color: #dac6d6;">input_str</span> = <span style="color: #A2BF8A;">'2 c c c'</span>
<span style="color: #dac6d6;">result</span> = p.parse(input_str)
<span style="color: #80A0C2;">assert</span> result == [<span style="color: #A2BF8A;">"2"</span>, [<span style="color: #A2BF8A;">"c"</span>, <span style="color: #A2BF8A;">"c"</span>, <span style="color: #A2BF8A;">"c"</span>]]

input_str = <span style="color: #A2BF8A;">'2'</span>
result = p.parse(input_str)
<span style="color: #80A0C2;">assert</span> result == [<span style="color: #A2BF8A;">"2"</span>, []]
</pre>
</div>

<pre class="example" id="orgb40038d">
Syntax equivalence `zero or more`:

    S: a*;

    terminals
    a: "a";

is equivalent to:

    S: a_0;
    a_0: a_1 {nops} | EMPTY;
    @collect
    a_1: a_1 a | a;

    terminals
    a: "a";

So using of `*` creates both `a_0` and `a_1` rules. Action attached to `a_0`
returns a list of matched `a` and empty list if no match is found. Please note
the [usage of `nops`](./disambiguation.md#nops-and-nopse). In case if
`prefer_shift` strategy is used using `nops` will perform both REDUCE and
SHIFT during GLR parsing in case what follows zero or more might be another
element in the sequence. This is most of the time what you need.
</pre>

<p>
Same as <code>one or more</code> this operator may use separator modifiers.
</p>

<pre class="example" id="org3e0691e">
Syntax equivalence `zero or more with separator `:

    S: a*[comma];

    terminals
    a: "a";
    comma: ",";

is equivalent to:

    S: a_0_comma;
    a_0_comma: a_1_comma {nops} | EMPTY;
    @collect_sep
    a_1_comma: a_1_comma comma a | a;

    terminals
    a: "a";

where action is attached to `a_0_comma` to provide returning a list of
matched `a` and empty list if no match is found.
</pre>
</div>
</div>

<div id="outline-container-greedy-repetitions" class="outline-4">
<h4 id="greedy-repetitions"><span class="section-number-4">2.4.4.</span> Greedy repetitions</h4>
<div class="outline-text-4" id="text-greedy-repetitions">
<p>
<code>*</code>, <code>+</code>, and <code>?</code> operators have their greedy counterparts. To make an
repetition operator greedy add <code>!</code> (e.g.Â <code>*!</code>, <code>+!</code>, and <code>?!</code>). These
versions will consume as much as possible before proceeding. You can
think of the greedy repetitions as a way to disambiguate a class of
ambiguities which arises due to a sequence of rules where earlier
constituent can match an input of various length leaving the rest to the
next rule to consume.
</p>

<p>
Consider this example:
</p>

<pre class="example" id="org5a80a8f">
S: "a"* "a"*;
</pre>

<p>
It is easy to see that this grammar is ambiguous, as for the input:
</p>

<pre class="example" id="org851a06b">
a a
</pre>

<p>
We have 3 solutions:
</p>

<pre class="example" id="org7195558">
1:S[0-&gt;3]
a_0[0-&gt;1]
    a_1[0-&gt;1]
    a[0-&gt;1, "a"]
a_0[2-&gt;3]
    a_1[2-&gt;3]
    a[2-&gt;3, "a"]
2:S[0-&gt;3]
a_0[0-&gt;0]
a_0[0-&gt;3]
    a_1[0-&gt;3]
    a_1[0-&gt;1]
        a[0-&gt;1, "a"]
    a[2-&gt;3, "a"]
3:S[0-&gt;3]
a_0[0-&gt;3]
    a_1[0-&gt;3]
    a_1[0-&gt;1]
        a[0-&gt;1, "a"]
    a[2-&gt;3, "a"]
a_0[3-&gt;3]
</pre>

<p>
If we apply greedy zero-or-more to the first element of the sequence:
</p>

<pre class="example" id="org849de77">
S: "a"*! "a"*;
</pre>

<p>
We have only one solution where all <code>a</code> tokens are consumed by the first
part of the rule:
</p>

<pre class="example" id="org9f27f2e">
S[0-&gt;3]
a_0[0-&gt;3]
    a_1[0-&gt;3]
    a_1[0-&gt;1]
        a[0-&gt;1, "a"]
    a[2-&gt;3, "a"]
a_0[3-&gt;3]
</pre>
</div>
</div>

<div id="outline-container-parenthesized-groups" class="outline-4">
<h4 id="parenthesized-groups"><span class="section-number-4">2.4.5.</span> Parenthesized groups</h4>
<div class="outline-text-4" id="text-parenthesized-groups">
<p>
You can use parenthesized groups at any place you can use a rule
reference. For example:
</p>

<pre class="example" id="orga9b608e">
S: a (b* a {left} | b);
terminals
a: "a";
b: "b";
</pre>

<p>
Here, you can see that <code>S</code> will match <code>a</code> and then either <code>b* a</code> or <code>b</code>.
You can also see that <a href="#user-meta-data">meta-data</a> can be applied at a
per-sequence level (in this case <code>{left}</code> applies to sequence <code>b* a</code>).
</p>

<p>
Here is a more complex example which uses repetitions, separators,
assignments and nested groups.
</p>

<pre class="example" id="orgdcf8eee">
S: (b c)*[comma];
S: (b c)*[comma] a=(a+ (b | c)*)+[comma];
terminals
a: "a";
b: "b";
c: "c";
comma: ",";
</pre>

<pre class="example" id="org88e2d90">
Syntax equivalence `parenthesized groups`:

    S: c (b* c {left} | b);
    terminals
    c: "c";
    b: "b";

is equivalent to:

    S: c S_g1;
    S_g1: b_0 c {left} | b;
    b_0: b_1 | EMPTY;
    b_1: b_1 b | b;
    terminals
    c: "c";
    b: "b";

So using parenthesized groups creates additional `_g&lt;n&gt;` rules (`S_g1` in the
example), where `n` is a unique number per rule starting from `1`. All other
syntactic sugar elements applied to groups behave as expected.
</pre>
</div>
</div>
</div>

<div id="outline-container-empty-built-in-rule" class="outline-3">
<h3 id="empty-built-in-rule"><span class="section-number-3">2.5.</span> <code>EMPTY</code> built-in rule</h3>
<div class="outline-text-3" id="text-empty-built-in-rule">
<p>
There is a special <code>EMPTY</code> rule you can reference in your grammars.
<code>EMPTY</code> rule will reduce without consuming any input and will always
succeed, i.e.Â it is empty recognition.
</p>
</div>
</div>

<div id="outline-container-named-matches-assignments" class="outline-3">
<h3 id="named-matches-assignments"><span class="section-number-3">2.6.</span> Named matches (<i>assignments</i>)</h3>
<div class="outline-text-3" id="text-named-matches-assignments">
<p>
In section  on <a href="components/builders.pre-processed.html#building-asts">actions</a> youcan see that semantic action
(Python callable) connected to a rule will be called with two parameters: a
context and a list of sub-expressions evaluation results. This require you to
use positional access in the list of sub-expressions.
</p>

<p>
<code>Named matches</code> (a.k.a <code>assignments</code>) enable giving a name to the
sub-expression directly in the grammar.
</p>

<p>
For example:
</p>

<pre class="example" id="org9d93d29">
S: first=a second=digit+[comma];

terminals
a: "a";
digit: /\d+/;
comma: ",";
</pre>

<p>
In this example root rule matches one <code>a</code> and then one or more digit
separated by a comma. You can see that the first sub-expression (<code>a</code>
match) is assigned to <code>first</code> while the second sub-expression
<code>digit+[comma]</code> is assigned to <code>second</code>.
</p>

<p>
<code>first</code> and <code>second</code> will now be an additional keyword parameters passed
to the semantic action. The values passed in using these parameters will
be the results of evaluation of the rules referenced by the assignments.
</p>

<p>
There are two kind of assignments:
</p>

<ul class="org-ul">
<li>plain assignment (<code>=</code>) &#x2013; will collect RHS and pass it to the action
under the names given by LHS,</li>
<li>bool assignment (<code>?=</code>) &#x2013; will pass <code>True</code> if the match return
non-empty result. If the result of RHS is empty the assignment will
result in <code>False</code> being passed to the action.</li>
</ul>

<p>
Each rule using named matches result in a dynamically created Python
class named after the rule. These classes are kept in a dictionary
<code>grammar.classes</code> and used to instantiate Python objects during parsing
by an implicitly set <a href="./actions.md#built-in-actions">built-in <code>obj</code>
action</a>.
</p>

<p>
Thus, for rules using named matches, default action is to create object
with attributes whose names are those of LHS of the assignments and
values are from RHS of the assignments (or boolean values for <code>bool</code>
assignments). Each object is an instance of corresponding dynamically
created Python class.
</p>

<p>
Effectively, using named matches enables automatic creation of a nice
AST.
</p>

<p>
!!! tip
</p>

<pre class="example" id="org46eebdf">
You can, of course, override default action either in the grammar
using `@` syntax or using `actions` dict given to the parser.
See the next section.
</pre>
</div>
</div>

<div id="outline-container-referencing-semantic-actions-from-a-grammar" class="outline-3">
<h3 id="referencing-semantic-actions-from-a-grammar"><span class="section-number-3">2.7.</span> Referencing semantic actions from a grammar</h3>
<div class="outline-text-3" id="text-referencing-semantic-actions-from-a-grammar">
<p>
By default <a href="./actions.md">action</a> with the name same as the rule name
will be searched in the accompanying <code>&lt;grammar&gt;_actions.py</code> file or
<a href="./parser.md#actions"><code>actions</code> dict</a>. You can override this by
specifying action name for the rule directly in the grammar using <code>@</code>
syntax. In that case a name given after <code>@</code> will be used instead of a
rule name.
</p>

<p>
For example:
</p>

<pre class="example" id="orgd6451d3">
@myaction
some_rule: first second;
</pre>

<div class="html" id="org41cfdb4">
<p>
&lt;!&#x2013; FIXME: Default actions &#x2013;&gt;
</p>

</div>

<p>
For rule <code>some_rule</code> action with the name <code>myaction</code> will be searched in
the <code>&lt;grammar&gt;_actions.py</code> module, <code>actions</code> dict or
<a href="./actions.md/#built-in-actions">built-in actions</a> provided by the
<code>parglare.actions</code> module. This is helpful if you have some common
action that can be used for multiple rules in your grammar. Also this
can be used to specify built-in action to be used for a rule directly in
the grammar.
</p>
</div>
</div>

<div id="outline-container-user-meta-data" class="outline-3">
<h3 id="user-meta-data"><span class="section-number-3">2.8.</span> User meta-data</h3>
<div class="outline-text-3" id="text-user-meta-data">
<p>
You can supply arbitrary meta-data for the productions and terminals in
the grammar in the form of key-value pairs. This can be used to augment
dynamic disambiguation strategies, error reporting etc.
</p>

<p>
To define meta-data put it inside the <code>{}</code> block of either rule,
production or terminal in the form of <code>name: value</code>, where <code>name</code> is a
valid ID and <code>value</code> is integer, float, bool (<code>true</code> or <code>false</code>) or
string in single quotes.
</p>

<p>
For example:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dac6d6;">grammar_str</span> = r<span style="color: #A2BF8A;">'''</span>
<span style="color: #A2BF8A;">MyRule: 'a' {left, 1, dynamic, nops,</span>
<span style="color: #A2BF8A;">              some_string:'My Label',</span>
<span style="color: #A2BF8A;">              some_bool: true,</span>
<span style="color: #A2BF8A;">              some_int: 3,</span>
<span style="color: #A2BF8A;">              some_float: 4.5};</span>
<span style="color: #A2BF8A;">'''</span>

grammar = Grammar.from_string(grammar_str)
<span style="color: #dac6d6;">my_rule</span> = grammar.get_nonterminal(<span style="color: #A2BF8A;">'MyRule'</span>)

<span style="color: #dac6d6;">prod</span> = my_rule.productions[<span style="color: #B58DAE; font-weight: bold;">0</span>]
<span style="color: #80A0C2;">assert</span> prod.some_string == <span style="color: #A2BF8A;">'My Label'</span>
<span style="color: #80A0C2;">assert</span> prod.some_bool <span style="color: #80A0C2;">is</span> <span style="color: #B58DAE;">True</span>
<span style="color: #80A0C2;">assert</span> prod.some_int == <span style="color: #B58DAE; font-weight: bold;">3</span>
<span style="color: #80A0C2;">assert</span> prod.some_float == <span style="color: #B58DAE; font-weight: bold;">4.5</span>
</pre>
</div>

<p>
In this example, user meta-data <code>some_string</code> with value <code>My Label</code> is
defined on the first production of rule <code>MyRule</code>. Please note that user
defined meta-data is accessed as an ordinary Python attribute. In the
example you can also see the definition of meta-data of various
supported types.
</p>

<p>
User meta-data can be defined at the rule level in which case all
production for the given rule inherit the meta-data.
</p>

<p>
For example:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dac6d6;">grammar_str</span> = r<span style="color: #A2BF8A;">'''</span>
<span style="color: #A2BF8A;">MyRule {label: 'My Label', nops}: 'a' {left, 1, dynamic};</span>
<span style="color: #A2BF8A;">'''</span>

grammar = Grammar.from_string(grammar_str)
<span style="color: #dac6d6;">my_rule</span> = grammar.get_nonterminal(<span style="color: #A2BF8A;">'MyRule'</span>)

<span style="color: #747474;"># </span><span style="color: #747474;">User meta-data is accessible on the non-terminal</span>
<span style="color: #80A0C2;">assert</span> my_rule.label == <span style="color: #A2BF8A;">'My Label'</span>

<span style="color: #747474;"># </span><span style="color: #747474;">The production has its own meta-data</span>
prod = my_rule.productions[<span style="color: #B58DAE; font-weight: bold;">0</span>]
<span style="color: #80A0C2;">assert</span> prod.assoc == ASSOC_LEFT
<span style="color: #80A0C2;">assert</span> prod.prior == <span style="color: #B58DAE; font-weight: bold;">1</span>
<span style="color: #80A0C2;">assert</span> prod.dynamic

<span style="color: #747474;"># </span><span style="color: #747474;">Rule-level meta-data are propagated to productions</span>
<span style="color: #80A0C2;">assert</span> prod.label == <span style="color: #A2BF8A;">'My Label'</span>
</pre>
</div>

<p>
Meta-data defined on the rule level can be overridden on the production
level. Also, rule can be specified multiple times. Propagation of each
rule meta-data is done only to the productions specified in the rule.
</p>

<p>
For example:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dac6d6;">grammar_str</span> = r<span style="color: #A2BF8A;">'''</span>
<span style="color: #A2BF8A;">MyRule {label: 'My Label', left}: 'first' {right,</span>
<span style="color: #A2BF8A;">                                            label: 'My overriden label'}</span>
<span style="color: #A2BF8A;">                                | 'second';</span>

<span style="color: #A2BF8A;">MyRule {label: 'Other rule'}: 'third' {left}</span>
<span style="color: #A2BF8A;">                            | 'fourth' {label: 'Fourth prod'};</span>
<span style="color: #A2BF8A;">'''</span>

grammar = Grammar.from_string(grammar_str)
<span style="color: #dac6d6;">my_rule</span> = grammar.get_nonterminal(<span style="color: #A2BF8A;">'MyRule'</span>)

<span style="color: #747474;"># </span><span style="color: #747474;">User meta-data is accessible on the non-terminal</span>
<span style="color: #747474;"># </span><span style="color: #747474;">Rule level meta-data are only those defined on the</span>
<span style="color: #747474;"># </span><span style="color: #747474;">first rule in the order of the definition.</span>
<span style="color: #80A0C2;">assert</span> my_rule.label == <span style="color: #A2BF8A;">'My Label'</span>

prod1 = my_rule.productions[<span style="color: #B58DAE; font-weight: bold;">0</span>]
<span style="color: #747474;"># </span><span style="color: #747474;">First production overrides meta-data</span>
<span style="color: #80A0C2;">assert</span> prod1.label == <span style="color: #A2BF8A;">'My overriden label'</span>
<span style="color: #80A0C2;">assert</span> prod1.assoc == ASSOC_RIGHT

<span style="color: #747474;"># </span><span style="color: #747474;">If not overriden it uses meta-data from the rule.</span>
prod2 = my_rule.productions[<span style="color: #B58DAE; font-weight: bold;">1</span>]
<span style="color: #80A0C2;">assert</span> prod2.label == <span style="color: #A2BF8A;">'My Label'</span>
<span style="color: #80A0C2;">assert</span> prod2.assoc == ASSOC_LEFT

<span style="color: #747474;"># </span><span style="color: #747474;">Third and fourth production belongs to the second rule so they</span>
<span style="color: #747474;"># </span><span style="color: #747474;">inherits its meta-data.</span>
prod3 = my_rule.productions[<span style="color: #B58DAE; font-weight: bold;">2</span>]
<span style="color: #80A0C2;">assert</span> prod3.label == <span style="color: #A2BF8A;">'Other rule'</span>
<span style="color: #80A0C2;">assert</span> prod3.assoc == ASSOC_LEFT

prod4 = my_rule.productions[<span style="color: #B58DAE; font-weight: bold;">3</span>]
<span style="color: #80A0C2;">assert</span> prod4.label == <span style="color: #A2BF8A;">'Fourth prod'</span>
<span style="color: #80A0C2;">assert</span> prod4.assoc == ASSOC_NONE
</pre>
</div>
</div>
</div>

<div id="outline-container-grammar-comments" class="outline-3">
<h3 id="grammar-comments"><span class="section-number-3">2.9.</span> Grammar comments</h3>
<div class="outline-text-3" id="text-grammar-comments">
<p>
In Rustemo grammar, comments are available as both line comments and
block comments:
</p>

<pre class="example" id="org7f90ab3">
// This is a line comment. Everything from the '//' to the end of line is a comment.

/*
  This is a block comment.
  Everything in between `/*`  and '*/' is a comment.
*/
</pre>

<p>
<code>admonish warning TODO: Grammar comments are not implemented yet. For this to land a layout support should be done.</code>
</p>
</div>
</div>

<div id="outline-container-handling-whitespaces-and-comments-in-your-language" class="outline-3">
<h3 id="handling-whitespaces-and-comments-in-your-language"><span class="section-number-3">2.10.</span> Handling whitespaces and comments in your language</h3>
<div class="outline-text-3" id="text-handling-whitespaces-and-comments-in-your-language">
<p>
By default parser will skip whitespaces. Whitespace skipping is
controlled by <a href="./parser.md#ws"><code>ws</code> parameter to the parser</a> which is
by default set to <code>'\n\t '</code>.
</p>

<p>
If you need more control of the layout, i.e.Â handling of not only
whitespaces but comments also, you can use a special rule <code>LAYOUT</code>:
</p>

<pre class="example" id="org6727d63">
LAYOUT: LayoutItem | LAYOUT LayoutItem | EMPTY;
LayoutItem: WS | Comment;

terminals
WS: /\s+/;
Comment: /\/\/.*/;
</pre>

<p>
This will form a separate layout parser that will parse in-between each
matched tokens. In this example whitespaces and line-comments will be
consumed by the layout parser.
</p>

<p>
If this special rule is found in the grammar <code>ws</code> parser parameter is
ignored.
</p>

<p>
Here is another example that gives support for both line comments and
block comments like the one used in the grammar language itself:
</p>

<pre class="example" id="org3c16a9b">
LAYOUT: LayoutItem | LAYOUT LayoutItem | EMPTY;
LayoutItem: WS | Comment;
Comment: '/*' CorNCs '*/' | LineComment;
CorNCs: CorNC | CorNCs CorNC | EMPTY;
CorNC: Comment | NotComment | WS;

terminals
WS: /\s+/;
LineComment: /\/\/.*/;
NotComment: /((\*[^\/])|[^\s*\/]|\/[^\*])+/;
</pre>

<p>
!!! tip
</p>

<pre class="example" id="org12053b3">
If `LAYOUT` is provided it *must* match before the first token, between any
two tokens in the input, and after the last token. If layout cannot be
empty, the input cannot start or end with a token. If this is not desired,
make sure to include `EMPTY` in the layout as one of its alternatives like
in the previous examples.
</pre>
</div>
</div>

<div id="outline-container-handling-keywords-in-your-language" class="outline-3">
<h3 id="handling-keywords-in-your-language"><span class="section-number-3">2.11.</span> Handling keywords in your language</h3>
<div class="outline-text-3" id="text-handling-keywords-in-your-language">
<p>
By default parser will match given string recognizer even if it is part
of some larger word, i.e.Â it will not require matching on the word
boundary. This is not the desired behavior for language keywords.
</p>

<p>
For example, lets examine this little grammar:
</p>

<pre class="example" id="org65ac8d3">
S: "for" name=ID "=" from=INT "to" to=INT;

terminals
ID: /\w+/;
INT: /\d+/;
</pre>

<p>
This grammar is intended to match statement like this one:
</p>

<pre class="example" id="org2af8b72">
for a=10 to 20
</pre>

<p>
But it will also match:
</p>

<pre class="example" id="org43c68b3">
fora=10 to20
</pre>

<p>
which is not what we wanted.
</p>

<p>
Rustemo allows the definition of a special terminal rule <code>KEYWORD</code>. This
rule must define a <a href="#regular-expression-recognizer">regular expression
recognizer</a>. Any string recognizer in the grammar that can be also
recognized by the <code>KEYWORD</code> recognizer is treated as a keyword and is
changed during grammar construction to match only on word boundary.
</p>

<p>
For example:
</p>

<pre class="example" id="org22887a8">
S: "for" name=ID "=" from=INT "to" to=INT;

terminals
ID: /\w+/;
INT: /\d+/;
KEYWORD: /\w+/;
</pre>

<p>
Now,
</p>

<pre class="example" id="orgc690129">
fora=10 to20
</pre>

<p>
will not be recognized as the words <code>for</code> and <code>to</code> are recognized to be
keywords (they can be matched by the <code>KEYWORD</code> rule).
</p>

<p>
This will be parsed correctly:
</p>

<pre class="example" id="org1e06351">
for a=10 to 20
</pre>

<p>
As <code>=</code> is not matched by the <code>KEYWORD</code> rule and thus doesn&rsquo;t require to
be separated from the surrounding tokens.
</p>

<pre class="example" id="org18f5429">
Rustemo uses integrated scanner so this example:

    for for=10 to 20

will be correctly parsed. `for` in `for=10` will be recognized as `ID` and
not as a keyword `for`, i.e. there is no lexical ambiguity due to tokenizer
separation.
</pre>
</div>
</div>
</div>
<div id="outline-container-org4dc300c" class="outline-2">
<h2 id="org4dc300c"><span class="section-number-2">3.</span> Configuration</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org09a2941" class="outline-3">
<h3 id="org09a2941"><span class="section-number-3">3.1.</span> Configuration</h3>
<div class="outline-text-3" id="text-3-1">
</div>
</div>
<div id="outline-container-org5dc3301" class="outline-3">
<h3 id="org5dc3301"><span class="section-number-3">3.2.</span> <code>build.rs</code> scripts</h3>
<div class="outline-text-3" id="text-3-2">
</div>
</div>
<div id="outline-container-org6e14d7b" class="outline-3">
<h3 id="org6e14d7b"><span class="section-number-3">3.3.</span> Using API</h3>
<div class="outline-text-3" id="text-3-3">
</div>
</div>
</div>
<div id="outline-container-org79cae78" class="outline-2">
<h2 id="org79cae78"><span class="section-number-2">4.</span> Components</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org7aabd9b" class="outline-3">
<h3 id="org7aabd9b"><span class="section-number-3">4.1.</span> Components</h3>
<div class="outline-text-3" id="text-4-1">
</div>
</div>
<div id="outline-container-orgcc9dc2b" class="outline-3">
<h3 id="orgcc9dc2b"><span class="section-number-3">4.2.</span> Lexers</h3>
<div class="outline-text-3" id="text-4-2">
<p>
This section describes the role of lexer in the parsing process, how to
configure and use string lexer and how to build a custom lexer.
</p>
</div>
</div>
<div id="outline-container-orgf692533" class="outline-3">
<h3 id="orgf692533"><span class="section-number-3">4.3.</span> Parsers</h3>
<div class="outline-text-3" id="text-4-3">
<p>
This section describes the role of the parser component and its interaction with
lexers and builders.
</p>
</div>
</div>
<div id="outline-container-orgb112195" class="outline-3">
<h3 id="orgb112195"><span class="section-number-3">4.4.</span> Builders</h3>
<div class="outline-text-3" id="text-4-4">
<p>
This section describes the role of builders in the parsing process, how to use
Rustemo provided builders and how to write a custom builder.
</p>
</div>
<div id="outline-container-org893b061" class="outline-4">
<h4 id="org893b061"><span class="section-number-4">4.4.1.</span> Building ASTs</h4>
</div>
<div id="outline-container-orge61accf" class="outline-4">
<h4 id="orge61accf"><span class="section-number-4">4.4.2.</span> Building generic parse trees</h4>
</div>
</div>
</div>
<div id="outline-container-orgf2dcbef" class="outline-2">
<h2 id="orgf2dcbef"><span class="section-number-2">5.</span> Rustemo CLI</h2>
<div class="outline-text-2" id="text-5">
<p>
Rustemo CLI
</p>
</div>
</div>
<div id="outline-container-org7393b97" class="outline-2">
<h2 id="org7393b97"><span class="section-number-2">6.</span> Handling errors</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org295b854" class="outline-3">
<h3 id="org295b854"><span class="section-number-3">6.1.</span> Handling errors</h3>
<div class="outline-text-3" id="text-6-1">
</div>
</div>
<div id="outline-container-resolving-lr-conflicts" class="outline-3">
<h3 id="resolving-lr-conflicts"><span class="section-number-3">6.2.</span> Resolving LR conflicts</h3>
<div class="outline-text-3" id="text-resolving-lr-conflicts">
</div>
</div>
<div id="outline-container-org7848243" class="outline-3">
<h3 id="org7848243"><span class="section-number-3">6.3.</span> Ambiguities</h3>
<div class="outline-text-3" id="text-6-3">
</div>
</div>
</div>
<div id="outline-container-org6afc27b" class="outline-2">
<h2 id="org6afc27b"><span class="section-number-2">7.</span> Tutorials</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org0683174" class="outline-3">
<h3 id="org0683174"><span class="section-number-3">7.1.</span> Calculator</h3>
<div class="outline-text-3" id="text-7-1">
</div>
</div>
</div>
<div id="outline-container-org0605872" class="outline-2">
<h2 id="org0605872"><span class="section-number-2">8.</span> Contributing</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org92108f6" class="outline-3">
<h3 id="org92108f6"><span class="section-number-3">8.1.</span> Contributing</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Contributions are welcome, and they are greatly appreciated!. You can contribute
code, documentation, tests, bug reports. Every little bit helps, and credit will
always be given. If you plan to make a significant contribution it would be
great if you first announce that in the Discussions.
</p>

<p>
You can contribute in many ways:
</p>
</div>

<div id="outline-container-org138cbe0" class="outline-4">
<h4 id="org138cbe0"><span class="section-number-4">8.1.1.</span> Types of Contributions</h4>
<div class="outline-text-4" id="text-8-1-1">
</div>
<ol class="org-ol">
<li><a id="org80c41c1"></a>Report Bugs<br />
<div class="outline-text-5" id="text-8-1-1-1">
<p>
Report bugs at <a href="https://github.com/igordejanovic/rustemo/issues">https://github.com/igordejanovic/rustemo/issues</a>.
</p>

<p>
If you are reporting a bug, please include:
</p>

<ul class="org-ul">
<li>Your operating system name and version.</li>
<li>Any details about your local setup that might be helpful in troubleshooting.</li>
<li>Detailed steps to reproduce the bug.</li>
</ul>
</div>
</li>


<li><a id="org2526536"></a>Fix Bugs<br />
<div class="outline-text-5" id="text-8-1-1-2">
<p>
Look through the GitHub issues for bugs. Anything tagged with &ldquo;bug&rdquo; and &ldquo;help
wanted&rdquo; is open to whoever wants to implement it.
</p>
</div>
</li>


<li><a id="org49de1f1"></a>Implement Features<br />
<div class="outline-text-5" id="text-8-1-1-3">
<p>
Look through the GitHub issues for features. Anything tagged with
&ldquo;enhancement/feature&rdquo; and &ldquo;help wanted&rdquo; is open to whoever wants to implement
it.
</p>
</div>
</li>

<li><a id="org148d133"></a>Write Documentation<br />
<div class="outline-text-5" id="text-8-1-1-4">
<p>
Rustemo could always use more documentation, whether as part of the official
Rustemo docs, in documentation comments, or even on the web in blog posts,
articles, and such.
</p>

<p>
Rustemo is using Org Mode for official documentation.
</p>
</div>
</li>

<li><a id="org79740b8"></a>How to Test the Documentation Locally<br />
<div class="outline-text-5" id="text-8-1-1-5">
<p>
To test the docs locally, you need to follow the first 3 instructions at the
[Get Started!](#get-started) section
</p>

<ol class="org-ol">
<li>Fork the repo (one-time effort)</li>
<li>Clone your fork locally (one-time effort)</li>
<li>Create a virtualenv for the fork and install the relevant libraries (one-time
effort)</li>
</ol>

<p>
Once you complete the above 3 instructions, you can now:
</p>

<ol class="org-ol">
<li>Activate the virtualenv</li>
<li>Run `mkdocs serve` at the root folder</li>
</ol>

<p>
`mkdocs` will run a webserver that serves the documentation at 127.0.0.1:8000
</p>

<p>
To make changes to the configurations, you can look at `mkdocs.yml`. For more
information on how to use mkdocs, visit this [site](<a href="https://www.mkdocs.org">https://www.mkdocs.org</a>).
</p>


<p>
### Submit Feedback
</p>

<p>
The best way to send feedback is to open a discussion at
<a href="https://github.com/textX/textX/discussions">https://github.com/textX/textX/discussions</a>
</p>

<p>
If you are proposing a feature:
</p>

<ul class="org-ul">
<li>Explain in detail how it would work.</li>
<li>Keep the scope as narrow as possible, to make it easier to implement.</li>
<li>Remember that this is a volunteer-driven project, and that contributions are
welcome :)</li>
</ul>


<p>
## Get Started!
</p>

<p>
Ready to contribute? Here&rsquo;s how to set up `textX` for local development.
</p>

<ol class="org-ol">
<li>Fork the `textX` repo on GitHub.</li>
<li><p>
Clone your fork locally:
</p>

<p>
$ git clone git@github.com:your<sub>name</sub><sub>here</sub>/textX.git
</p></li>

<li><p>
Install your local copy into a virtualenv. This is how you set up your fork
for local development:
</p>

<p>
$ cd textX/
$ python -m venv venv
$ source venv/bin/activate
$ ./install-dev.sh
</p>

<p>
Previous stuff is needed only the first time. To continue working on textX
later you just do:
</p>

<p>
$ cd textX/
$ source venv/bin/activate
</p>

<p>
Note that on Windows sourcing syntax is a bit different. Check the docs for
virtualenv.
</p>

<p>
An excellent overview of available tools for Python environments management
can be found
[here](<a href="https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe">https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe</a>)
</p>

<p>
To verify that everything is setup properly run tests:
</p>

<p>
$ flake8
$ py.test tests/functional/
</p></li>

<li><p>
Create a branch for local development::
</p>

<p>
$ git checkout -b name-of-your-bugfix-or-feature
</p>

<p>
Now you can make your changes locally.
</p></li>

<li><p>
When you&rsquo;re done making changes, check that your changes pass flake8, the
tests, and have a look at the coverage:
</p>

<p>
$ flake8
$ py.test tests/functional/
$ coverage run &#x2013;source textx -m py.test tests/functional
$ coverage report
</p>

<p>
You can run all this at once with provided script `runtests.sh`
</p>

<p>
$ ./runtests.sh
</p>

<p>
In case you have doubts, have also a look at the html rendered version of
the coverage results:
</p>

<p>
$ coverage html
</p></li>

<li><p>
Commit your changes and push your branch to GitHub:
</p>

<p>
$ git add .
$ git commit -m &ldquo;Your detailed description of your changes.&rdquo;
$ git push origin name-of-your-bugfix-or-feature
</p></li>

<li>Submit a pull request through the GitHub website.</li>
</ol>


<p>
## Pull Request Guidelines
</p>

<p>
Before you submit a pull request, check that it meets these guidelines:
</p>

<ol class="org-ol">
<li>The pull request should include tests.</li>
<li>If the pull request adds/changes functionality, the docs should be updated.</li>
<li>The pull request should work for Python 3.6+. Check
<a href="https://github.com/textX/textX/actions">https://github.com/textX/textX/actions</a> and make sure that the tests pass for
all supported Python versions.</li>
</ol>


<p>
## Tips
</p>

<p>
To run a subset of tests:
</p>

<p>
```
$ py.test tests/functional/mytest.py
```
</p>

<p>
or a single test:
</p>

<p>
```
$ py.test tests/functional/mytest.py::some<sub>test</sub>
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org9f3a288" class="outline-3">
<h3 id="org9f3a288"><span class="section-number-3">8.2.</span> Bootstrapping</h3>
<div class="outline-text-3" id="text-8-2">
<p>
This section describes the bootstrap process which is essential to understand in
order to contribute to the development of the Rustemo library.
</p>

<p>
It is usual for compiler compilers to be implemented using themselves. Rustemo
is no different. in <code>rustemo/src/lang</code> you can find grammar <code>rustemo.rustemo</code> which
is a description of the rustemo grammar language. This description is then used
to generate a parser for rustemo grammar files.
</p>

<p>
The problem with bootstrapping is a classical chicken and egg problem. To
generate the parser you need a working parser. The problem is solved by using a
previous version to generate the next.
</p>

<p>
While the solution seems simple it is not easily achieved from the
organizational point of view. E.g., when you change parser generator code you
would like to have rustemo parser regenerated with the new code but the current
parser version might not be functional at that point.
</p>

<p>
Thus, rustemo defines a bootstrapping process to help with the development. The
idea is to build bootstrapping rustemo binary with the parser code from the git
<code>main</code> branch and the rest of the code from the current source tree.
</p>

<p>
If you are not changing the rustemo grammar or the parser code generator you
won&rsquo;t need bootstrapping and should proceed as usual with Cargo commands.
</p>

<p>
But, if you do need to change the rustemo grammar or parser code generator you
should install bootstrapping binary with the following command.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo install --path rustemo --features boostrap --debug
</pre>
</div>

<p>
The <code>--debug</code> switch is optional but will provide faster build and the built
binary will provide better error repors in case of problems.
</p>

<p>
Note the use of <code>--features bootstrap</code>. This command will checkout rustemo parser
files (parser and actions) from the git <code>main</code> branch, do the build with the rest
of the code and install the binary.
</p>

<p>
You can verify that the bootstrapping binary is used by checking the version:
</p>

<pre class="example" id="org87390f3">
$ rustemo --version
rustemo 0.1.0-1a45d75ca4-bootstrap
</pre>

<div class="note" id="org15919cb">
<p>
It is assumed that the <code>main</code> branch contains a working parser.
</p>

</div>

<p>
When the bootstrapping binary is installed you develop as usual and run tests:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo test
</pre>
</div>

<p>
Whenever you change the rustemo grammar you should regenerate the parser code
with <code>rustemo</code> binary:
</p>

<div class="org-src-container">
<pre class="src src-sh">rustemo rustemo/src/lang/rustemo.rustemo
</pre>
</div>

<p>
If bootstrapping binary is used, code generation templates from the working tree
when the binary was last built are used. Thus, regenerate bootstrapping binary
whenever you change parser code generation templates.
</p>

<p>
This will also check your grammar for syntax and semantic errors and report
diagnostics.
</p>

<p>
If feature <code>bootstrap</code> is not provided during rustemo installation, Cargo proceeds
as usual by using current versions of parser files to build the binary.
</p>
</div>
</div>
</div>

<div id="outline-container-org8621dd2" class="outline-2">
<h2 id="org8621dd2"><span class="section-number-2">9.</span> Random notes</h2>
<div class="outline-text-2" id="text-9">
<p>
These are quick notes that should be reworked and go elsewhere.
</p>
</div>

<div id="outline-container-org6306f46" class="outline-3">
<h3 id="org6306f46"><span class="section-number-3">9.1.</span> Random notes</h3>
<div class="outline-text-3" id="text-9-1">
</div>
</div>

<div id="outline-container-orgcefb2b2" class="outline-3">
<h3 id="orgcefb2b2"><span class="section-number-3">9.2.</span> <code>@vec</code> rule annotation</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Rustemo performs a usual rule pattern recognition to decide what type to use but
for better control user should annotate rules where more complex types are used (like Vec).
</p>

<p>
E.g.
</p>

<pre class="example">
A: As A | A | EMPTY;
</pre>

<p>
Is a standard patter for zero or more of <code>A</code>. Automatically generated actions will
recognize this but you need to annotate the rule in order to use <code>Vec</code>.
</p>

<pre class="example">
@vec
A: As A | A | EMPTY;
</pre>

<p>
When syntax sugar for regex-like operators is finished this will just be:
</p>

<pre class="example">
A*
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Igor Dejanovic</p>
<p class="date">Created: 2022-11-30 Wed 17:44</p>
</div>
</body>
</html>
