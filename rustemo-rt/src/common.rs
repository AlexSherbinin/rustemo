/// Define a module using the generated parser from a `.rustemo` file.
///
/// You have to specify the name of the module and the path of the file
/// generated by Rustemo. If the input is in the root directory, you can
/// omit it.
///
/// # Example
/// ```ignore
/// // load parser in src/parser.rustemo
/// rustemo_mod!(parser);
///
/// // load parser in src/lex/parser.rustemo
/// rustemo_mod!(parser, "/lex/parser.rs");
///
/// // define a public module
/// rustemo_mod!(pub parser);
/// ```
///
/// This macro and the general idea of bootstrapping approach is taken from the
/// lalrpop project (https://github.com/lalrpop/lalrpop)
#[macro_export]
macro_rules! rustemo_mod {
    ($(#[$attr:meta])* $vis:vis $modname:ident) => {
        rustemo_mod!($(#[$attr])* $vis $modname, concat!("/", stringify!($modname), ".rs"));
    };

    ($(#[$attr:meta])* $vis:vis $modname:ident, $source:expr) => {
        $(#[$attr])* $vis mod $modname { include!(concat!(env!("OUT_DIR"), $source)); }
    };
}

type URI = String;

#[derive(PartialEq, Debug, Clone)]
pub struct Position {
    pub line: u32,
    pub column: u32,
}

#[derive(PartialEq, Debug, Clone)]
pub struct Range {
    pub start: Position,
    pub end: Position,
}

/// Location defines the textual object inside a textual file. The file is
/// identified by its `URI` while the object is defined as a `Range`.
#[derive(PartialEq, Debug, Clone)]
pub struct Location {
    pub uri: URI,
    pub range: Range,
}
